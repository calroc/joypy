<h1 id="functions">Functions</h1>
<p>stack → stack</p>
<p>We can catagorize functions into those that rearrange things on the stack but don't otherwise process them, those that perform some process on them, and those that call back into the joy() function to execute one or more quoted programs themselves. And, of course, there are commands that do more than one or all three.</p>
<p>Commands that execute quoted programs are called &quot;Combinators&quot; and they are the key to Joy's expressiveness and power. The joy() function by itself wouldn't accomplish much but with the availability of several combinators it becomes a powerhouse.</p>
<p>Commands that just rearrange things on the stack can be written in python as simple tuple unpacking and repacking.</p>
<p>Definitions, functions defined by equations, refactoring and how important it is..</p>
<table class="sourceCode python numberLines" startFrom="43"><tr class="sourceCode"><td class="lineNumbers"><pre>43
44
45
</pre></td><td class="sourceCode"><pre><code class="sourceCode python"><span class="ch">from</span> .btree <span class="ch">import</span> get, insert
<span class="ch">from</span> .parser <span class="ch">import</span> text_to_expression
<span class="ch">from</span> .stack <span class="ch">import</span> list_to_stack, iter_stack</code></pre></td></tr></table>
<h2 id="aliases">ALIASES</h2>
<p>We allow for having alternate names for functions by this mapping.</p>
<table class="sourceCode python numberLines" startFrom="52"><tr class="sourceCode"><td class="lineNumbers"><pre>52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="sourceCode"><pre><code class="sourceCode python">ALIASES = (
  (<span class="st">&#39;add&#39;</span>, [<span class="st">&#39;+&#39;</span>]),
  (<span class="st">&#39;mul&#39;</span>, [<span class="st">&#39;*&#39;</span>]),
  (<span class="st">&#39;truediv&#39;</span>, [<span class="st">&#39;/&#39;</span>]),
  (<span class="st">&#39;mod&#39;</span>, [<span class="st">&#39;%&#39;</span>, <span class="st">&#39;rem&#39;</span>, <span class="st">&#39;remainder&#39;</span>, <span class="st">&#39;modulus&#39;</span>]),
  (<span class="st">&#39;eq&#39;</span>, [<span class="st">&#39;=&#39;</span>]),
  (<span class="st">&#39;ge&#39;</span>, [<span class="st">&#39;&gt;=&#39;</span>]),
  (<span class="st">&#39;gt&#39;</span>, [<span class="st">&#39;&gt;&#39;</span>]),
  (<span class="st">&#39;le&#39;</span>, [<span class="st">&#39;&lt;=&#39;</span>]),
  (<span class="st">&#39;lshift&#39;</span>, [<span class="st">&#39;&lt;&lt;&#39;</span>]),
  (<span class="st">&#39;lt&#39;</span>, [<span class="st">&#39;&lt;&#39;</span>]),
  (<span class="st">&#39;ne&#39;</span>, [<span class="st">&#39;&lt;&gt;&#39;</span>, <span class="st">&#39;!=&#39;</span>]),
  (<span class="st">&#39;rshift&#39;</span>, [<span class="st">&#39;&gt;&gt;&#39;</span>]),
  (<span class="st">&#39;sub&#39;</span>, [<span class="st">&#39;-&#39;</span>]),
  (<span class="st">&#39;xor&#39;</span>, [<span class="st">&#39;^&#39;</span>]),
  (<span class="st">&#39;succ&#39;</span>, [<span class="st">&#39;++&#39;</span>]),
  (<span class="st">&#39;pred&#39;</span>, [<span class="st">&#39;--&#39;</span>]),
  (<span class="st">&#39;rolldown&#39;</span>, [<span class="st">&#39;roll&lt;&#39;</span>]),
  (<span class="st">&#39;rollup&#39;</span>, [<span class="st">&#39;roll&gt;&#39;</span>]),
  (<span class="st">&#39;id&#39;</span>, [<span class="st">&#39;•&#39;</span>]),
  )


<span class="kw">def</span> add_aliases(items, A=ALIASES):
  D = <span class="dt">dict</span>(items)
  <span class="kw">for</span> name, aliases in A:
    <span class="kw">try</span>:
      F = D[name]
    <span class="kw">except</span> <span class="ot">KeyError</span>:
      <span class="kw">continue</span>
    <span class="kw">for</span> alias in aliases:
      D[alias] = F
  <span class="kw">return</span> D.items()</code></pre></td></tr></table>
<h2 id="functionwrapper">FunctionWrapper</h2>
<p>Right now, this just allows functions to have a nice repr().</p>
<table class="sourceCode python numberLines" startFrom="92"><tr class="sourceCode"><td class="lineNumbers"><pre>92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
</pre></td><td class="sourceCode"><pre><code class="sourceCode python"><span class="kw">class</span> FunctionWrapper(<span class="dt">object</span>):
  <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, f):
    <span class="ot">self</span>.f = f
    <span class="ot">self</span>.name = f.<span class="dt">__name__</span>.rstrip(<span class="st">&#39;_&#39;</span>)
    <span class="ot">self</span>.__doc__ = f.__doc__ or <span class="dt">str</span>(f)

  <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, stack, expression, dictionary):
    <span class="kw">return</span> <span class="ot">self</span>.f(stack, expression, dictionary)

  <span class="kw">def</span> <span class="ot">__repr__</span>(<span class="ot">self</span>):
    <span class="kw">return</span> <span class="ot">self</span>.name


<span class="kw">class</span> SimpleFunctionWrapper(FunctionWrapper):

  <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, stack, expression, dictionary):
    <span class="kw">return</span> <span class="ot">self</span>.f(stack), expression, dictionary


<span class="kw">class</span> BinaryBuiltinWrapper(FunctionWrapper):

  <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, stack, expression, dictionary):
    (a, (b, stack)) = stack
    result = <span class="ot">self</span>.f(b, a)
    <span class="kw">return</span> (result, stack), expression, dictionary


<span class="kw">class</span> UnaryBuiltinWrapper(FunctionWrapper):

  <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, stack, expression, dictionary):
    (a, stack) = stack
    result = <span class="ot">self</span>.f(a)
    <span class="kw">return</span> (result, stack), expression, dictionary


<span class="kw">class</span> DefinitionWrapper(FunctionWrapper):

  <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, name, body_text, dictionary, doc=<span class="ot">None</span>):
    <span class="ot">self</span>.name = <span class="ot">self</span>.<span class="dt">__name__</span> = name
    <span class="ot">self</span>.body = text_to_expression(body_text, dictionary)
    <span class="ot">self</span>._body = <span class="dt">tuple</span>(iter_stack(<span class="ot">self</span>.body))
    <span class="ot">self</span>.__doc__ = doc or body_text

  <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, stack, expression, dictionary):
    expression = list_to_stack(<span class="ot">self</span>._body, expression)
    <span class="kw">return</span> stack, expression, dictionary</code></pre></td></tr></table>
<p>Given some text describing a Joy function definition parse it and return a DefinitionWrapper.</p>
<table class="sourceCode python numberLines" startFrom="143"><tr class="sourceCode"><td class="lineNumbers"><pre>143
144
145
146
147
148
</pre></td><td class="sourceCode"><pre><code class="sourceCode python">  <span class="ot">@classmethod</span>
  <span class="kw">def</span> parse_definition(class_, defi, dictionary):
    name, proper, body_text = (n.strip() <span class="kw">for</span> n in defi.partition(<span class="st">&#39;==&#39;</span>))
    <span class="kw">if</span> not proper:
      <span class="kw">raise</span> <span class="ot">ValueError</span>(<span class="st">&#39;Definition </span><span class="ot">%r</span><span class="st"> failed&#39;</span> % (defi,))
    <span class="kw">return</span> class_(name, body_text, dictionary)</code></pre></td></tr></table>
<h2 id="generate_definitions">generate_definitions()</h2>
<table class="sourceCode python numberLines" startFrom="153"><tr class="sourceCode"><td class="lineNumbers"><pre>153
154
155
156
157
158
159
160
</pre></td><td class="sourceCode"><pre><code class="sourceCode python"><span class="kw">def</span> generate_definitions(defs, dictionary):
  <span class="kw">for</span> definition in defs.splitlines():
    definition = definition.strip()
    <span class="kw">if</span> not definition or definition.isspace():
      <span class="kw">continue</span>
    F = DefinitionWrapper.parse_definition(definition, dictionary)
    dictionary = insert(dictionary, F.name, F)
  <span class="kw">return</span> dictionary</code></pre></td></tr></table>
